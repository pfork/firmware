/** @file axolotl.c
    @brief implements the signal protocol

    The signal protocol defines interactions between two peers, these
    have different roles during this interaction:

    - publisher of prekeys: each user of this protocol publishes
      prekeys generated by the function axolotl_prekey.

    - initiator: a user or the protocol who uses the prekey of another
      peer and initiates a handshake with the publisher of the prekey
      using the function axolotl_handshake_init.

    - responder must be equal with the publisher of the prekey used by
      the initiator using the function axolotl_handshake_resp.

    This implementation of the signal protocol deviates from the
    reference implementation in a few aspects:

    - it adds a post-quantum element to the x3dh handshake
    - it replaces SHA256 with Blake2b
    - Currently the names of the peers are not added as an
      authenticated component in x3dh.

    @copyright
    This file is part of pitchfork.

    pitchfork is free software: you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public License
    as published by the Free Software Foundation, either version 3 of
    the License, or (at your option) any later version.

    pitchfork is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with pitchfork. If not, see <http://www.gnu.org/licenses/>.
*/
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>

#include "randombytes_pitchfork.h"
#include "crypto_secretbox.h"
#include "crypto_generichash.h"

#include "axolotl.h"
#include "xeddsa.h"
#include "xeddsa_keygen.h"

#define PADDEDHCRYPTLEN (16+sizeof(long long)*2 + crypto_scalarmult_curve25519_BYTES+crypto_secretbox_MACBYTES)

static void bubble_sort(uint8_t ptr[BagSize][2],int s);
static BagEntry* bag_put(BagEntry bag[]);
static void bag_init(BagEntry bag[]);
static void bag_del(BagEntry *bag);
#if AXOLOTL_DEBUG
static void bag_dump(BagEntry bag[]);
#endif // AXOLOTL_DEBUG

/** @brief this function generates axolotl prekeys
 *
 *  These prekeys can be published and act as a 0th step in a axolotl
 *  key exchange.
 *
 *  @param prekey: the public part of the prekey
 *  @param ctx: the private part of the prekey, keep this somewhere secure
 *              until someone uses the public part to initiate a handshake
 *  @param keypair: long-term curve25519 key of the user generating the prekey
 */
void axolotl_prekey(Axolotl_PreKey *prekey, Axolotl_prekey_private *ctx, const Axolotl_KeyPair *keypair) {
  // copy identity key into ctx dhis
  memcpy(ctx->dhis, keypair->sk, crypto_scalarmult_curve25519_BYTES);
  // create ephemeral key and store it in ctx
  randombytes_buf(ctx->eph,crypto_scalarmult_curve25519_BYTES);
  // also create DHRs
  randombytes_buf(ctx->dhrs,crypto_scalarmult_curve25519_BYTES);
  // and publish in prekey
  memcpy(prekey->identitykey, keypair->pk, crypto_scalarmult_curve25519_BYTES);
  crypto_scalarmult_curve25519_base(prekey->ephemeralkey, ctx->eph);
  crypto_scalarmult_curve25519_base(prekey->DHRs, ctx->dhrs);
  // xeddsa sign dhrs+ephemeral with ltidkey
  uint8_t random[64];
  randombytes_buf(random,sizeof(random));
  xed25519_sign(prekey->sig, /* 64 bytes */
                keypair->sk, /* 32 bytes */
                ((uint8_t*) prekey)+crypto_scalarmult_curve25519_BYTES,
                crypto_scalarmult_curve25519_BYTES*2, /* <= 256 bytes - thus we cannot include
                                                         the newhope component in the sig :/ */
                random); /* 64 bytes */
  // sprinkle it with a pinch of new hope
  newhope_keygen(prekey->newhope, &ctx->newhope);
}

/** @brief this function generates axolotl prekey response
 *
 *  This function generates a response to a peers prekey. Someone
 *  initiating a key exchange with a peer first acquires a prekey
 *  (generated with axolotl_prekey) of that peer. Then the handshake
 *  is initiated (using axolotl_handshake_init) with this prekey and
 *  the response, and the response along with a first message is sent
 *  to the peer.
 *
 *  @param resp: the public part of the resp
 *  @param ctx: the private part of the resp, used in axolotl_handshake_init
 *  @param keypair: long-term curve25519 key of the user generating the response
 */
void axolotl_kexresp(Axolotl_Resp *resp, Axolotl_prekey_private *ctx, const Axolotl_KeyPair *keypair) {
  // copy identity key into ctx dhis
  memcpy(ctx->dhis, keypair->sk, crypto_scalarmult_curve25519_BYTES);
  // create ephemeral key and store it in ctx
  randombytes_buf(ctx->eph,crypto_scalarmult_curve25519_BYTES);
  // also create DHRs
  randombytes_buf(ctx->dhrs,crypto_scalarmult_curve25519_BYTES);
  // and publish in resp
  memcpy(resp->identitykey, keypair->pk, crypto_scalarmult_curve25519_BYTES);
  crypto_scalarmult_curve25519_base(resp->ephemeralkey, ctx->eph);
  crypto_scalarmult_curve25519_base(resp->DHRs, ctx->dhrs);
  // xeddsa sign dhrs+ephemeral with ltidkey
  uint8_t random[64];
  randombytes_buf(random,sizeof(random));
  xed25519_sign(resp->sig, /* 64 bytes */
                keypair->sk, /* 32 bytes */
                ((uint8_t*) resp)+crypto_scalarmult_curve25519_BYTES,
                crypto_scalarmult_curve25519_BYTES*2, /* <= 256 bytes */
                random); /* 64 bytes */
}

/** @brief perform tripledh with newhope pq

    Triple DH+Newhope performs cross DH between two peers having two
    keys each, while also completing a Newhope key exchange:

    - an identity key (Ai,Bi), and
    - an ephemeral key (Ae, Be).

    the cross DH is then performed on these pairs:
    (Ai,Be)+(Bi,Ae)+(Ae,Be)

    The order of the parameters to these operations depends on the
    order in which the peers are acting.

    A Newhope key exchange is also run in parallel.

    the results of the 3 DH operations are concatenated with the
    output of the Newhope key exchange, which then is hashed into the
    resulting master key (mk);

    @param mk: output parameter containing shared secret.

    @param poly: output parameter containing the newhope
    response. This parameter must be NULL for the party whose prekey
    was used. and must hold
*/
static int tripledh(uint8_t *mk, uint8_t* poly, const Axolotl_prekey_private *ctx, const Axolotl_PreKey *prekey, int isAlice) {
  uint8_t sec[crypto_scalarmult_curve25519_BYTES * 4], *ptr = sec;

  if(isAlice <= 0) {
    // 3 DHs
    if(crypto_scalarmult_curve25519(ptr, ctx->dhis, prekey->ephemeralkey)!=0) {
      return 1;
    }
    ptr+=crypto_scalarmult_curve25519_BYTES;

    if(crypto_scalarmult_curve25519(ptr, ctx->eph, prekey->identitykey)!=0) {
      return 1;
    }
    ptr+=crypto_scalarmult_curve25519_BYTES;

    if(crypto_scalarmult_curve25519(ptr, ctx->eph, prekey->ephemeralkey)!=0) {
      return 1;
    }
  } else {
    // 3 DHs
    if(crypto_scalarmult_curve25519(ptr, ctx->eph, prekey->identitykey)!=0) {
      return 1;
    }
    ptr+=crypto_scalarmult_curve25519_BYTES;

    if(crypto_scalarmult_curve25519(ptr, ctx->dhis, prekey->ephemeralkey)!=0) {
      return 1;
    }
    ptr+=crypto_scalarmult_curve25519_BYTES;

    if(crypto_scalarmult_curve25519(ptr, ctx->eph, prekey->ephemeralkey)!=0) {
      return 1;
    }
  }

  // sprinkle with a little new hope
  ptr+=crypto_scalarmult_curve25519_BYTES;
  if(poly!=NULL) newhope_sharedb(ptr, poly, prekey->newhope);
  else newhope_shareda(ptr, &ctx->newhope, prekey->newhope);

  // and hash for the result
  crypto_generichash(mk, crypto_scalarmult_curve25519_BYTES, // output
                     sec, sizeof(sec),                       // msg
                     NULL, 0);                               // no key
  memset(sec,0, sizeof(sec));

  return 0;
}

    // setup ad
//    memcpy(ad, ctx->dhis.pk, crypto_scalarmult_curve25519_BYTES);
//    memcpy(ad+crypto_scalarmult_curve25519_BYTES, prekey->DHRs, crypto_scalarmult_curve25519_BYTES);
// or
//    memcpy(resp->ad, prekey->DHRs, crypto_scalarmult_curve25519_BYTES);
//    memcpy(resp->ad+crypto_scalarmult_curve25519_BYTES, ctx->dhis.pk, crypto_scalarmult_curve25519_BYTES);
  // prepare response

/** @brief derivectx initializes an ratchet context from the shared secret and the peers public keys
 *
 *  Alice:
 *   KDF from triple-DH: RK, HKs, HKr, NHKs, NHKr, CKs, CKr
 *   DHRs, DHRr = <none>, Bi
 *   Ns, Nr = 0, 0
 *   PNs = 0
 *   bobs_first_message = False
 *  Bob:
 *   KDF from triple-DH: RK, HKr, HKs, NHKr, NHKs, CKr, CKs
 *   DHRs, DHRr = Bi, <none>
 *   Ns, Nr = 0, 0
 *   PNs = 0
 *   bobs_first_message = True
 */
static int derivectx(Axolotl_ctx *ctx, uint8_t *mk, const Axolotl_PreKey *prekey) {
  // derive root key
  crypto_generichash(ctx->rk, crypto_scalarmult_curve25519_BYTES,
                     mk, sizeof(mk),
                     (uint8_t*) "RK", 2);
  if(ctx->isAlice) {
    // DHRr = peer DHRs
    memcpy(ctx->dhrr, prekey->DHRs, crypto_scalarmult_curve25519_BYTES);
    // clear DHRs
    memset(ctx->dhrs.sk,0,crypto_scalarmult_curve25519_BYTES);
    memset(ctx->dhrs.pk,0,crypto_scalarmult_curve25519_BYTES);

    // derive HKs
    crypto_generichash(ctx->hks, crypto_scalarmult_curve25519_BYTES,
                       mk, sizeof(mk),
                       (uint8_t*) "HKs", 3);
    // derive HKr
    crypto_generichash(ctx->hkr, crypto_scalarmult_curve25519_BYTES,
                       mk, sizeof(mk),
                       (uint8_t*) "HKr", 3);

    // derive NHKs
    crypto_generichash(ctx->nhks, crypto_scalarmult_curve25519_BYTES,
                       mk, sizeof(mk),
                       (uint8_t*) "NHKs", 4);
    // derive NHKr
    crypto_generichash(ctx->nhkr, crypto_scalarmult_curve25519_BYTES,
                       mk, sizeof(mk),
                       (uint8_t*) "NHKr", 4);
    // derive CKs
    crypto_generichash(ctx->cks, crypto_scalarmult_curve25519_BYTES,
                       mk, sizeof(mk),
                       (uint8_t*) "CKs", 3);
    // derive CKr
    crypto_generichash(ctx->ckr, crypto_scalarmult_curve25519_BYTES,
                       mk, sizeof(mk),
                       (uint8_t*) "CKr", 3);
    ctx->bobs1stmsg = 0;
  } else {
    // derive HKs
    crypto_generichash(ctx->hks, crypto_scalarmult_curve25519_BYTES,
                       mk, sizeof(mk),
                       (uint8_t*) "HKr", 3);
    // derive HKr
    crypto_generichash(ctx->hkr, crypto_scalarmult_curve25519_BYTES,
                       mk, sizeof(mk),
                       (uint8_t*) "HKs", 3);

    // derive NHKs
    crypto_generichash(ctx->nhks, crypto_scalarmult_curve25519_BYTES,
                       mk, sizeof(mk),
                       (uint8_t*) "NHKr", 4);
    // derive NHKr
    crypto_generichash(ctx->nhkr, crypto_scalarmult_curve25519_BYTES,
                       mk, sizeof(mk),
                       (uint8_t*) "NHKs", 4);
    // derive CKs
    crypto_generichash(ctx->cks, crypto_scalarmult_curve25519_BYTES,
                       mk, sizeof(mk),
                       (uint8_t*) "CKr", 3);
    // derive CKr
    crypto_generichash(ctx->ckr, crypto_scalarmult_curve25519_BYTES,
                       mk, sizeof(mk),
                       (uint8_t*) "CKs", 3);
    ctx->bobs1stmsg = 1;
  }
  ctx->ns = 0;
  ctx->nr = 0;
  ctx->pns = 0;
  memset(mk, 0, crypto_scalarmult_curve25519_BYTES);

  return 0;
}

/** @brief initiates a handshake by consuming a previously published prekey
 *
 *  verifies the signature on the prekey, then performs a pq3dh,
 *  finally derives a double ratchet context.
 */
int axolotl_handshake(Axolotl_ctx* ctx, Axolotl_Resp *resp, const Axolotl_PreKey *prekey, Axolotl_prekey_private *private) {
  memset(ctx,0,sizeof(Axolotl_ctx));
  bag_init(ctx->skipped_HK_MK);

  // check sig on prekey
  if(xed25519_verify(prekey->sig, // sig
                     prekey->identitykey, // pubkey
                     prekey->ephemeralkey, // msg
                     crypto_scalarmult_curve25519_BYTES*2)!=0) {
    // fail
    return 1;
  }

  uint8_t mk[crypto_scalarmult_curve25519_BYTES];
  // set ctx->isAlice
  ctx->isAlice=memcmp(resp->identitykey, prekey->identitykey, crypto_scalarmult_curve25519_BYTES) <=0;

  if(tripledh(mk, resp->newhope, private, prekey, ctx->isAlice)!=0) return 1;

  // mk is the shared secret derived of the triple dh which seeds all keys:
  return derivectx(ctx,mk,prekey);
}

/** @brief responds to a handshake by consuming a previously published prekey
 *
 *  verifies the signature on the prekey, then performs a pq3dh,
 *  finally derives a double ratchet context. Different parameter
 *  types than in axololt_handshake_init make this function necessary.
 */
int axolotl_handshake_resp(Axolotl_ctx* ctx, const Axolotl_Resp *resp, Axolotl_prekey_private *private) {
  memset(ctx,0,sizeof(Axolotl_ctx));
  bag_init(ctx->skipped_HK_MK);

  // check sig on resp
  if(xed25519_verify(resp->sig, // sig
                     resp->identitykey, // pubkey
                     resp->ephemeralkey, // msg
                     crypto_scalarmult_curve25519_BYTES*2)!=0) {
    // fail
    return 1;
  }

  uint8_t mk[crypto_scalarmult_curve25519_BYTES];
  // set ctx->isAlice - but we need to derive the pubkey from private
  uint8_t pk[crypto_scalarmult_curve25519_BYTES];
  uint8_t sk[crypto_scalarmult_curve25519_BYTES];
  memcpy(sk, private->dhis, crypto_scalarmult_curve25519_BYTES);
  sc_clamp(sk);
  curve25519_keygen(pk, sk); // derive pubkey
  ctx->isAlice=memcmp(pk, resp->identitykey, crypto_scalarmult_curve25519_BYTES) <=0;

  if(tripledh(mk, NULL, private, (const Axolotl_PreKey*) resp, ctx->isAlice)!=0) return 1;
  return derivectx(ctx,mk,(const Axolotl_PreKey*) resp);
}

/**
   @brief attempts to decrypt message with keys we had to skip due to out-of-order pkts

   the (hopefully) same in python:
```
def try_skipped_keys(self, hcrypt, hnonce, mcrypt, mnonce):
    for mk, hkr in self.skipped_HK_MK.items():
        try: nacl.crypto_secretbox_open(hcrypt, hnonce, hkr)
        except: continue
        try: msg = nacl.crypto_secretbox_open(mcrypt, mnonce, mk)
        except: continue
        del self.skipped_HK_MK[mk]
        return msg
```
*/
static int try_skipped(Axolotl_ctx *ctx, uint8_t *out, uint32_t *outlen,
                const uint8_t *hcrypt, const uint8_t *hnonce,
                const uint8_t *mcrypt, const uint32_t mcrypt_len, const uint8_t *mnonce) {
  uint8_t paddedout[mcrypt_len];
  int i;
  for(i=0;i<BagSize;i++) {
    if(ctx->skipped_HK_MK[i].id==0xff || ctx->skipped_HK_MK[i].id==0) continue;
    if(crypto_secretbox_open(paddedout, mcrypt, mcrypt_len, mnonce, ctx->skipped_HK_MK[i].mk)!=0) continue;
    memcpy(out, paddedout+32, mcrypt_len - 32);
    *outlen = mcrypt_len-32;
    bag_del(&(ctx->skipped_HK_MK[i]));
    return 1;
  }
  return 0;
}

/** @brief Generates keys for skipped message

  stage_skipped_header_and_message_keys() : Given a current header
  key, a current message number, a future message number, and a
  chain key, calculates and stores all skipped-over message keys (if
  any) in a staging area where they can later be committed, along
  with their associated header key.

  Returns the chain key and message key corresponding to the future
  message number.
*/
static void stage_skipped_keys(uint8_t* ckp, uint8_t* mk,  // output
                               const long long nr, const long long np, uint8_t *ck, // input
                               BagEntry stagedkeys[BagSize]) {
  long long i;
  uint8_t _ckp[crypto_secretbox_KEYBYTES];
  memcpy(_ckp, ck, crypto_secretbox_KEYBYTES);
#if AXOLOTL_DEBUG
    if(np < nr) {
      printf("smaller, %lld < %lld\n", np, nr);
    } else if(np > nr) {
      printf("bigger, %lld < %lld\n", np, nr);
    }
#endif
  BagEntry *slot;
  for(i=0;i<np - nr;i++) {
    slot = bag_put(stagedkeys);
    crypto_generichash(slot->mk, crypto_secretbox_KEYBYTES, // mk=
                         _ckp, crypto_secretbox_KEYBYTES,  // h(ck,
                         (uint8_t*) "MK", 2);              // "MK")
    crypto_generichash(_ckp, crypto_secretbox_KEYBYTES,   // mk=
                       _ckp, crypto_secretbox_KEYBYTES,   // h(ck,
                       (uint8_t*) "CK", 2);               // "CK")
  }
  if(mk!=NULL) {
#if AXOLOTL_DEBUG
    print_key("ck", _ckp);
#endif
    crypto_generichash(mk, crypto_secretbox_KEYBYTES,     // mk=
                       _ckp, crypto_secretbox_KEYBYTES,   // h(ck,
                       (uint8_t*) "MK", 2);               // "MK")
  }
  if(ckp!=NULL) {
    crypto_generichash(ckp, crypto_secretbox_KEYBYTES,    // ck=
                       _ckp, crypto_secretbox_KEYBYTES,   // h(ck,
                       (uint8_t*) "CK", 2);               // "CK")
  }
}




/**
  as per https://github.com/trevp/axolotl/wiki/newversion (Nov 19, 2013 Â· 41 revisions)

  Receiving messages
  -------------------
  Local variables:
    MK  : message key
    Np  : Purported message number
    PNp : Purported previous message number
    CKp : Purported new chain key
    DHp : Purported new DHr
    RKp : Purported new root key
    NHKp, HKp : Purported new header keys

  if (plaintext = try_skipped_header_and_message_keys()):
    return plaintext

  if Dec(HKr, header):
    Np = read()
    CKp, MK = stage_skipped_header_and_message_keys(HKr, Nr, Np, CKr)
    if not Dec(MK, ciphertext):
      raise undecryptable
    if bobs_first_message:
      DHRr = read()
      RK = HASH(RK || ECDH(DHRs, DHRr))
      HKs = NHKs
      NHKs, CKs = KDF(RK)
      erase(DHRs)
      bobs_first_message = False
  else:
    if not Dec(NHKr, header):
      raise undecryptable()
    Np, PNp, DHRp = read()
    stage_skipped_header_and_message_keys(HKr, Nr, PNp, CKr)
    RKp = HASH(RK || ECDH(DHRs, DHRr))
    HKp = NHKr
    NHKp, CKp = KDF(RKp)
    CKp, MK = stage_skipped_header_and_message_keys(HKp, 0, Np, CKp)
    if not Dec(MK, ciphertext):
      raise undecryptable()
    RK = RKp
    HKr = HKp
    NHKr = NHKp
    DHRr = DHRp
    RK = HASH(RK || ECDH(DHRs, DHRr))
    HKs = NHKs
    NHKs, CKs = KDF(RK)
    erase(DHRs)
  commit_skipped_header_and_message_keys()
  Nr = Np + 1
  CKr = CKp
  return read()

  updates: if skipped key, only skipped_MK
  if bobs first message: rk, dhrr, hks, nhks, dhrs, cks, bobs1stmsg(can be write once, from 1 to 0)
  if next msgkey:        rk, dhrr, hks, nhks, dhrs, hkr, nhkr,
  skipped_HK? nr, ckr
*/
int ax_recv(Axolotl_ctx *ctx,
            uint8_t *paddedout, /*!< needs to be unpadded manually by skipping 32 bytes */
            uint32_t *out_len, /*!< excluding padding */
            const uint8_t *hnonce, const uint8_t *mnonce,
            const uint8_t *hcrypt, uint8_t *paddedmcrypt,
            const int mcryptlen, uint8_t *mk) {

  uint8_t paddedhcrypt[PADDEDHCRYPTLEN];
  uint8_t headers[PADDEDHCRYPTLEN];
  uint8_t tmp[crypto_secretbox_KEYBYTES];
  BagEntry stagedkeys[BagSize];
  memset(stagedkeys, 0xff, sizeof(stagedkeys));

  unsigned long long np;
  memset(paddedmcrypt,0,16);

  memset(paddedhcrypt,0,16);
  memcpy(paddedhcrypt+16, hcrypt, sizeof(paddedhcrypt)-16);

  // fun starts^Wends here
  if(try_skipped(ctx, paddedout, out_len, paddedhcrypt, hnonce, paddedmcrypt, mcryptlen, mnonce)==1) {
    return 0;
  }

  uint8_t ckp[crypto_secretbox_KEYBYTES];
  if(crypto_secretbox_open(headers, paddedhcrypt, sizeof(paddedhcrypt), hnonce, ctx->hkr)==0) {
    memcpy((uint8_t*) &np, headers+32, sizeof(long long));
    // CKp, MK = stage_skipped_keys(HKr, Nr, Np, CKr)
    stage_skipped_keys(ckp, mk, ctx->nr, np, ctx->ckr, stagedkeys);
    if(crypto_secretbox_open(paddedout, paddedmcrypt, mcryptlen, mnonce, mk)!=0) {
      return 1;
    }
    *out_len = mcryptlen-32;
    if(ctx->bobs1stmsg!=0) {
      memcpy(ctx->dhrr, headers+32+2*sizeof(long long), crypto_secretbox_KEYBYTES);
      if(crypto_scalarmult_curve25519(tmp, ctx->dhrs.sk, ctx->dhrr)!=0) {
        return 1;
      }
      crypto_generichash(ctx->rk, crypto_secretbox_KEYBYTES, // output
                         ctx->rk, crypto_secretbox_KEYBYTES, // msg
                         tmp, crypto_secretbox_KEYBYTES);    // no key
      memcpy(ctx->hks, ctx->nhks, crypto_secretbox_KEYBYTES);
      if(ctx->isAlice) {
        crypto_generichash(ctx->nhks, crypto_secretbox_KEYBYTES, // output
                           ctx->rk, crypto_secretbox_KEYBYTES,   // msg
                           (uint8_t*) "NHKs", 4);                // no key
        crypto_generichash(ctx->cks, crypto_secretbox_KEYBYTES,  // output
                           ctx->rk, crypto_secretbox_KEYBYTES,   // msg
                           (uint8_t*) "CKs", 3);                 // no key
      } else {
        crypto_generichash(ctx->nhks, crypto_secretbox_KEYBYTES, // output
                           ctx->rk, crypto_secretbox_KEYBYTES,   // msg
                           (uint8_t*) "NHKr", 4);                // no key
        crypto_generichash(ctx->cks, crypto_secretbox_KEYBYTES,  // output
                           ctx->rk, crypto_secretbox_KEYBYTES,   // msg
                           (uint8_t*) "CKr", 3);                 // no key
      }
      memset(ctx->dhrs.sk, 0, crypto_secretbox_KEYBYTES);
      ctx->bobs1stmsg=0;
    }
  } else {
    if(crypto_secretbox_open(headers, paddedhcrypt, sizeof(paddedhcrypt), hnonce, ctx->nhkr)!=0) {
      return 1;
    }
    unsigned long long pnp;
    memcpy((uint8_t*) &np, headers+32, sizeof(long long));
    memcpy((uint8_t*) &pnp, headers+32+sizeof(long long), sizeof(long long));
    uint8_t dhrp[crypto_secretbox_KEYBYTES];
    memcpy(dhrp, headers+32+sizeof(long long)*2, crypto_secretbox_KEYBYTES);
    // stage_skipped_keys(HKr, Nr, PNp, CKr)
    stage_skipped_keys(NULL, NULL, ctx->nr, pnp, ctx->ckr, stagedkeys);
    uint8_t rkp[crypto_secretbox_KEYBYTES];
    if(crypto_scalarmult_curve25519(tmp, ctx->dhrs.sk, ctx->dhrr)!=0) {
      return 1;
    }
    crypto_generichash(rkp, crypto_secretbox_KEYBYTES,
                       ctx->rk, crypto_secretbox_KEYBYTES,
                       tmp, crypto_scalarmult_curve25519_BYTES);
    uint8_t hkp[crypto_secretbox_KEYBYTES];
    memcpy(hkp, ctx->nhkr, crypto_secretbox_KEYBYTES);
    uint8_t nhkp[crypto_secretbox_KEYBYTES];
    if(ctx->isAlice) {
      crypto_generichash(nhkp, crypto_secretbox_KEYBYTES,
                         rkp, crypto_secretbox_KEYBYTES,
                         (uint8_t*) "NHKr", 4);
      crypto_generichash(ckp, crypto_secretbox_KEYBYTES,
                         rkp, crypto_secretbox_KEYBYTES,
                         (uint8_t*) "CKr", 3);
    } else {
      crypto_generichash(nhkp, crypto_secretbox_KEYBYTES,
                         rkp, crypto_secretbox_KEYBYTES,
                         (uint8_t*) "NHKs", 4);
      crypto_generichash(ckp, crypto_secretbox_KEYBYTES,
                         rkp, crypto_secretbox_KEYBYTES,
                         (uint8_t*) "CKs", 3);
    }
    // CKp, MK = stage_skipped_keys(HKp, 0, Np, CKp)
    stage_skipped_keys(ckp, mk, 0LL, np, ckp, stagedkeys);

    if(crypto_secretbox_open(paddedout, paddedmcrypt, mcryptlen, mnonce, mk)!=0) {
      return 1;
    }

    *out_len = sizeof(paddedout)-32;
    memcpy(ctx->rk, rkp, crypto_secretbox_KEYBYTES);
    memcpy(ctx->hkr, hkp, crypto_secretbox_KEYBYTES);
    memcpy(ctx->nhkr, nhkp, crypto_secretbox_KEYBYTES);
    memcpy(ctx->dhrr, dhrp, crypto_secretbox_KEYBYTES);

    if(crypto_scalarmult_curve25519(tmp, ctx->dhrs.sk, ctx->dhrr)!=0) {
      return 1;
    };
    crypto_generichash(ctx->rk, crypto_secretbox_KEYBYTES,       // RK =
                       ctx->rk, crypto_secretbox_KEYBYTES,       // h(rk,
                       tmp, crypto_scalarmult_curve25519_BYTES); // tmp)
    memcpy(ctx->hks, ctx->nhks, crypto_secretbox_KEYBYTES);
    if(ctx->isAlice) {
      crypto_generichash(ctx->nhks, crypto_secretbox_KEYBYTES,
                         ctx->rk, crypto_secretbox_KEYBYTES,
                         (uint8_t*) "NHKs", 4);
      crypto_generichash(ctx->cks, crypto_secretbox_KEYBYTES,
                         ctx->rk, crypto_secretbox_KEYBYTES,
                         (uint8_t*) "CKs", 3);
    } else {
      crypto_generichash(ctx->nhks, crypto_secretbox_KEYBYTES,
                         ctx->rk, crypto_secretbox_KEYBYTES,
                         (uint8_t*) "NHKr", 4);
      crypto_generichash(ctx->cks, crypto_secretbox_KEYBYTES,
                         ctx->rk, crypto_secretbox_KEYBYTES,
                         (uint8_t*) "CKr", 3);
    }
    memset(ctx->dhrs.sk, 0, crypto_secretbox_KEYBYTES);
  }
  /*
  # commit_skipped_header_and_message_keys() : Commits any skipped-over message keys from the
  # staging area to persistent storage (along with their associated header keys).
  self.skipped_HK_MK.update(self.staged_HK_MK)
  self.staged_HK_MK = {}
  */
  int i;
  BagEntry *curentry;
  for(i=0;i<BagSize;i++) {
    if(stagedkeys[i].id==0xff || stagedkeys[i].id==0) continue;
    curentry = bag_put(ctx->skipped_HK_MK);
    memcpy(curentry->mk, &(stagedkeys[i].mk), crypto_secretbox_KEYBYTES);
    bag_del(&(stagedkeys[i]));
  }

  ctx->nr = np +1;
  memcpy(ctx->ckr, ckp, crypto_secretbox_KEYBYTES);

  return 0;
}

static void bubble_sort(uint8_t ptr[BagSize][2],int s) {
  int i,j;
  uint8_t temp;
  for(i=1;i<s;i++) {
    for(j=0;j<s-i;j++) {
      if(ptr[j][0]>(ptr[j+1][0])) {
        temp=ptr[j][0];
        ptr[j][0]=ptr[j+1][0];
        ptr[j+1][0]=temp;

        temp=ptr[j][1];
        ptr[j][1]=ptr[j+1][1];
        ptr[j+1][1]=temp;
      }
    }
  }
}

static BagEntry* bag_put(BagEntry bag[]) {
  int i;
  uint8_t minid=0xff,
    maxid=0,
    idx=0xff, minidx=0xff, delidx=0xff;

  // iterate through bag, looking for empty spaces, max and min ids.
  for(i=0;i<BagSize;i++) {
    if(bag[i].id<minid && bag[i].id!=0) {
      minid=bag[i].id;
      minidx=i;
    }
    if(bag[i].id>maxid && bag[i].id!=0xff) {
      maxid=bag[i].id;
    }
    if(bag[i].id==0xff && idx==0xff) {
      // found empty space
      idx=i;
    }
    if(bag[i].id==0 && delidx==0xff) {
      // found deleted space
      delidx=i;
    }
  }
  if(idx==0xff) {
    // did not find empty space
    if(delidx!=0xff && BagReuseDeleted) {
      // reuse deleted
      idx = delidx;
    } else {
      if(!BagReuseDeleted && minidx==0xff) {
        printf("bag erradicated, and no reuse\n");
        while(1);
      }
      // overwrite minidx
      idx=minidx;
    }
  }

  // try to assign id to new item.
  if(maxid<254) {
    bag[idx].id=maxid+1;
    return &bag[idx]; // easy, done
  }
  // we have to reassign all ids
  uint8_t idlist[BagSize][2], ptr;
  for(i=0, ptr=0;i<BagSize;i++) {
    if(i==idx) {
      idlist[ptr][0]=255;
      idlist[ptr++][1]=i;
    } else if(bag[i].id!=0xff && bag[i].id!=0) {
      idlist[ptr][0]=bag[i].id;
      idlist[ptr++][1]=i;
    }
  }
  bubble_sort(idlist,ptr);
  for(i=0;i<ptr;i++) {
    bag[idlist[i][1]].id=i+1;
  }
  return &bag[idx]; // done
}

static void bag_init(BagEntry bag[]) {
  // needed for operation on flash rom:
  memset(bag, 0xff, sizeof(BagEntry) * BagSize);
}

static void bag_del(BagEntry *bag) {
  bag->id=0;
  memset(bag->mk,0,crypto_scalarmult_curve25519_BYTES);
}
